# test 발표

- 테스트와 테스트 주도 개발
    - 테스트란? (단위 테스트와 통합 테스트)
    - 테스트 주도 개발이란?

# 테스트와 테스트 주도 개발

## 테스트란?

> 테스팅이란 버그를 찾는 행위를 뜻한다.
> 

테스팅을 하는 이유:

- Sw가 고장을 일으키기 전에 결함 발견을 위하여
- 결함을 수정하고 테스트한 후 일정 품질의 수준까지 높이기 위해서
- 요구되는 테스트를 정해진 예산과 일정 안에 요과적으로 수행하기 위해서.

장점:

개발 속도의 비약적인 증가

단점:

테스트 기술에 대한 선행 지식 필수

### 단위 테스트(Unit test)

의미:

가장 좁은 범위의 테스트이자, 가장 기초적이며 중요한 테스트.

각각의 유닛이나 컴포넌트들이 의도한대로 작동하는지 확인해보는 목적의 테스트.

테스트 대상:

클래스가 되거나 메소드가 되는것이 일반적이다.

특징:

- 단위 테스트는 주로 "WhiteBox test"를 통해 수행된다.
    
    → 안이 훤히 들여다보이는 상태로 테스트하는 것
    
    → 테스트하고자하는 컴포넌트 내부의 로직과 의존성을 모두 아는 상태로 테스트하는 것
    

- 코드가 바뀌면 조금 곤란해진다.
    
    단위 테스트의 주요 쟁점
    
    1. 컴포넌트 내부에서 어떠한 메소드가 호출되었는지?
    2. 컴포넌트 내부에서 어떠한 변수가 특정값이 되었는지?
    3. 컴포넌트가 의도한 값을 반환하는지?
        
        →코드가 변경되면 테스트가 실패하게 된다 (테스트가 깨진다.)
        
        →Whitebox 테스트는 코드변경시에 같이 수정해주어야하는 필요성이 있습니다.
        
        그래서 코드를 바꾸면 테스트를 바꿔야한다는 점에서 큰 단점을 느낄 수 있지만, 
        
        CI/CD 과정에서 테스트를 매번 수행할 수 있게 되어 협업 과정에서 도움이 된다.
        
        1. 타인이 작성/수정한 테스트코드를 보고 기능을 쉽게 이해할 수 있다.
        2. 타인이 새로 추가한 코드가 정상적으로 작동한다는 안정감을 얻을 수 있다
        3. 타인이 만들어놓은 코드를 수정할 때, 테스트코드를 동시에 수정하기에 의도를 깊게 이해하여컴포넌트의 목적에 반하는 코드 주입을 방지할 수 있다.
- 설계에 미스를 느끼고 어느 방향으로 고쳐야하는가(설계해야하는가) 생각하게 된다.
    
    하나의 컴포넌트에서 너무 많은 일을 하고 있으면 테스트하기 굉장히 어렵다.
    
    **TDD에서는 테스트하기가 어렵다면 설계 개선이 필요하다는 신호** 라고 보는데
    
    하나의 컴포넌트가 지나치게 많은 일을 한다고 볼 수 있기 때문에, 이런 경우에 가능하다면
    
    컴포넌트의 책임을 분리하여 좋은 구조로 나아갈 수 있는 계기가 될 수도 있다.
    

### 통합 테스트(Integration Test)

의미:

단위 테스트에서 Mocking으로 바꿔서 의존하던 대상들을 실제로 바꾸어서 테스트하는 것.

단위 테스트가 이루어진 후에 통합 테스트가 이뤄지는것이 일반적인 방식이다.

실제 객체들로 바꾸었을 때, 시스템이 정상적으로 통합되어 작동되는지 확인하기 위한 테스팅입니다.

단위 테스트**의 경우**

Service에서 Repository를 사용합한다. 단위 테스트에서 Repository는 모조품이기에

어떠한 DB를 실제로 작동시키지 않는다. 단지 어떤 질문에 대해(id 가 1인 유저를 줘)

정해져 있는 답(유저A 반환)을 할 뿐, 실제 DB에 저장되어 있는 값을 주지 않는다.

통합 테스트**의 경**

Service에서 Repository를 사용한다. 여기서의 Repository는 실제 DB와 연결된

Repository입니다. 이 경우에 실제 MySQL, Oracle, PostgreSQL로 각 각 바꿔가면서

실제로 시스템이 동작하는지 테스팅한다.

+추가적인 테스트

### Regression Test

시스템에 변화가 생겼을 때(새로운 패치, 업그레이드, 버그수정)시에 기존에 잘 작동함을 확인한

테스트들이 시스템 통합후에도 여전히 깨지지 않았는지 확인하는 테스트이다.

### Acceptance Test

통합 테스트와 유사하지만, 컴포넌트에 중점을 두기보다는, 실제 사용하는데 초점을 둔다.

그래서 실제 고객이나 유저가 SW가 요구사항대로 작동하는지 확인해보는 과정이다.

→ 비즈니스 로직대로 움직이는지 테스트하는 과정이라고 보면 됨.

가장 마지막 단계의 테스팅이다.

## 테스트 주도 개발이란?

> TDD는 SW를 만드는 것이 테스트 작성에 의해 가이드되는 방식. 테스트가 개발을 이끌어나간다! →테스트코드 작성이 개발보다 선행된다.
> 

Kent Beck이 고안한 단어이고, 아래와 같은 절차를 반복적으로 따르는 개발방식이다.

1. 추가하고싶은 자그마한 기능을 만들기 전에 테스트를 진행하라
2. 테스트가 성공할 때까지 기능코드를 작성하라
3. 새로운 코드와 이전 코드가 잘 structured되도록 리팩토링을 진행하라

1법칙에 의하면 우리는 실제 코드를 작성하기도 전에 테스트 코드를 작성해야 하는데…

믿기지 않지만 아직 코드가 없지만 테스트를 작성하고, 테스트가 실패하는 것을 손수 본 후에

(2)에서 만들려는 코드를 작성하는것이 원칙이다.

굉장히 이상해보이지만 장점이 있다.

1. 순서를 반대로 하면 테스트하기 쉬운 코드를 만들도록 유도된다

2. 테스트 자체가 설계활동이 된다

3. 모듈화된 코드가 만들어진다

개발해야 하는 사항을 미리 정의하고, 각 기능의 입/출력을 미리 정한 뒤, 기능을 구현하는것은 굉장히 일반적인 과정이다.

이때 TDD 방식으로 개발하게 된다면, 테스트 코드를 먼저 작성함으로써 개발사항과 각 기능의 입/출력 요구사항을 코드로 문서화한 후 기능을 개발하게 된다.

→ 테스트코드는 코드를 작성하고 그것을 테스트 하기 위해 작성한다는 통념에서 벗어나

테스트코드 먼저 작성하고 실제 코드를 만들게 된다.

## +) 로버트 마틴의 3가지 법칙

1. 실패한 단위 테스트를 만들기 전에는 제품 코드를 만들지 않는다.
2. 컴파일이 안 되거나 실패한 단위 테스트가 있으면 더 이상 단위 테스트를 만들지 않는다.
3. 실패한 단위 테스트를 통과하는 이상의 제품 코드는 만들지 않는다.

TDD의 장점:

- 개발하고자 하는 대상에서 기대하는 것을 테스트 코드로 미리 명확하게 정의할 수 있다.
    - 소프트웨어를 개발할 때 중요한 것은 이 소프트웨어가 “어떻게”가 돌아가느냐가 아니라 “무엇을” 제공해줄 것이냐 이다.
    - 테스트 코드로 먼저 작성하면 입/출력과 발생하는 예외를 무엇으로 정의해야 할지 먼저 명확하게 정의할 수 있다.
    - 덕분에 좀 더 사용하는 쪽의 코드나 사람 입장에서 사용하기 좋은 코드를 작성할 수 있게 된다.
- 테스트를 훨씬 꼼꼼히 작성하게 된다.
    - 테스트 코드는 사실 작성하기 번거로운 존재이다. 특히 구현을 먼저하고 테스트를 작성하면, 테스트 작성에 느슨해지고, 자칫 예외나 몇몇 시나리오에 대한 테스트를 놓칠 수 있다.
    - TDD로 진행하게 되면, 테스트를 먼저 작성하기 때문에, 테스트 코드를 누락시킬 빈도가 낮아진다.
    - 테스트 코드가 탄탄하게 있기 때문에, 리팩토링도 겁먹지 않고 진행할 수 있다.
- 테스트 코드가 깔끔한 코드 사용 문서가 된다.
    - TDD에서 테스트 코드는 테스트할 대상의 구현을 모른 채 작성되기 때문에, 철저히 사용자 중심적으로 작성된다.
    - 따라서 테스트 코드는 코드를 사용하기 위해 필요한 최소한의 내용만 담게된다.

TDD의 단점:

- 테스트가 가능하도록 코드를 설계하는 것은 어렵다.
    - TDD를 진행하게 되면 모든 코드들을 테스트 가능하도록 설계해야한다.
    - 테스트 가능하도록 코드를 설계하려면, 추상화, 의존성 주입 등을 잘 활용해야한다.
    - 또한 테스트 환경을 제대로 구축하는 것(Docker compose, DB 데이터 초기화 등)의 작업은 꽤나 번거롭다.
- 익숙하지 않은 채 TDD를 진행하면, 개발 프로세스가 느려질 수 있다.
    - 위에서 말했듯, 테스트 가능한 코드와 테스트 환경을 만드는 것 자체가 어려운 일이다.
    - 구현 로직보다 테스트 코드를 작성하고 고민히는데 훨씬 시간이 많이 들 수 있다.