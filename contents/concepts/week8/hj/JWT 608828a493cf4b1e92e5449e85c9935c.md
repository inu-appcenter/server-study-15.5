# JWT

상태: In progress

# 0. 토큰이란?

토큰(Token)은 말 그대로 동전이라는 뜻 이지만, 웹 상에서는 특정한 목적으로만 사용 가능한 동전에 일종의 “권한’ 을 주는 것을 말합니다.

### 웹 상에서의 토큰

서버에서는 사용자가 결제한 돈도 오고가서 권한이라는것이 중요하다. 인터넷에 사이트를 올리면 전 세계의 사용자들이나 해커들이 접근 가능한데 사용자들의 돈을 보호하려면 **본인만 접근 가능**하도록 본인 확인 수단이 필요한데 그 수단으로 토큰을 이용합니다.

### 토큰을 사용하는 이유

- **Stateless**

  : 토큰 기반 인증은 서버에서 사용자의 정보를 가지지 않기 때문에 무상태성을 가져서 서버가 확장을 하여도 문제가 생기지 않게 됩니다.

상태를 가지는 세션을 사용하는 방식에서 서버를 확장한다면 사용자가 로그인 했을 때, 유저는 처음 로그인한 서버에만 요청하는 문제가 발생할 수 있다. 하지만 토큰을 사용하게 되면 어떠한 서버로 요청이 가도 상관 없게 됩니다.

- **인증 정보를 다른 어플리케이션으로 전달한다.**

  : 대표적인 예제로  OAuth 가 있습니다. 페이스북/구글 같은 소셜 계정들을 이용하여 다른 웹서비스에서도 로그인 할수 있게합니다.

- **보안**

   : 토큰 기반 인증 시스템을 사용하여 어플리케이션의 보안을 높일 수 있습니다. 단, 토큰 기반 인증을 사용한다고 해서 무조건 해킹의 위험에서 벗어나는 것은 아닙니다.

 

---

# 1. JWT란 무엇인가요?

![Untitled](JWT%20608828a493cf4b1e92e5449e85c9935c/Untitled.png)

**JWT(JSON Web Token)**는 당사자 간에 정보를 **JSON 형태**로 안전하게 전송하기 위한 토큰입니다. **JWT**는 **URI로 이용할 수 있는 문자열**로만 구성돼 있으며, **디지털 서명이 적용**돼 있어 신뢰할 수 있습니다.

**JWT**는 주로 서버와의 통신에서 **권한 인가**를 위해 사용됩니다. **URL에서 사용할 수 있는 문자열**로만 구성돼 있기 때문에 **HTTP 구성요소 어디든 위치**할 수 있습니다.

---

### JWT의 종류

### Access Token

**Access Token** 은 보호된 정보들(유저의 이메일, 연락처, 사진 등) 에 접근할 수 있는 권한 부여에 사용한다. 클라이언트가 처음 인증을 받게 될 때(로그인 시), Access, Aefresh Token 두가지를 다 받지만, 실제로 권한을 얻는 데 사용하는 토큰은 **Access Token**입니다.

### Refresh Token

권한을 부여 받는데엔 Access Token 만 가지고 있으면 됩니다. 하지만 Access Token을 만약 **악의적인 유저가 얻어냈다면** 이 악의적인 유저는 자신이 진짜 유저인것 마냥 서버에 여러가지 요청을 보낼 수 있습니다. 그렇기 때문에 **Access Token에는 비교적 짧은 유효기간**을 주어 탈취 되더라도 오랫동안 사용할 수 없도록 하는 것이 좋습니다.

Access Token의 유효 기간이 만료된다면 **Refresh Token**을 사용하여 **새로운 Access Token**을 발급받습니다. 이 때 유저는 **다시 로그인 할 필요가 없습니다**. 

---

### JWT의 구조

**JWT**는 점 (’.’) 으로 구분된 아래의 세 부분으로 구성됩니다.

- 헤더(Header)
- 내용(Payload)
- 서명(Signature)

따라서 JWT는 일반적으로 아래와 같은 형식을 띠고 있습니다.

![Untitled](JWT%20608828a493cf4b1e92e5449e85c9935c/Untitled%201.png)

![Untitled](JWT%20608828a493cf4b1e92e5449e85c9935c/Untitled%202.png)

---

### 헤더(Header)

**JWT의 헤더**는 검증과 관련된 내용을 담고 있습니다. 두 가지 정보를 포함하고 있는데 , 바로 **alg와 typ** 속성입니다. 

![Untitled](JWT%20608828a493cf4b1e92e5449e85c9935c/Untitled%203.png)

**alg 속성**에서는 해싱 알고리즘을 지정합니다. 해싱 알고리즘은 보통 **SHA256** 또는 **RSA**를 사용하며, 토큰을 검증할 때 사용되는 서명 부분에서 사용됩니다. 위 그림의 **HS256**은 ‘**HMACSHA256**’ 알고리즘을 사용한다는 의미입니다. 

**typ 속성**에는 **타입을 지정**합니다.  

이렇게 완성된 헤더는 **Base64Url** 형식으로 인코딩 돼 사용됩니다. 

---

### HMAC SHA-256

**HMACSHA256이란?
HMAC(Hash-based Message Authentication Code, 해시 기반메시지인증 코드)** 와 **SHA(Secure Hash Algorithm)-256** 약자의 조합으로 ,**인증코드(여기서는 MAC) 를 해시(여기서는 SHA) 값을 이용해 만드는 방법**을 말합니다.

---

**해시 알고리즘이란?**

**해시는 많은 용량의 데이터를 고정된 크기의 고유 값으로 만드는 것** 입니다. **두 데이터를 이용해 만든 해시 값**이 각각 있을 때, **해시 값들은 데이터가 일치하는 경우**에만 일치합니다. 데이터가 약간만 달라져도 **해시에는 예측할 수 없는 큰 변화**가 발생하며 **전혀 다른 값**이 되며, 이를 **눈사태** 효과라고도 합니다.

---

**HMAC이란?** 

**송신자와 수신자만이 공유하고  있는 키와 메시지를 혼합해 해시 값을 만드는 것이다.**

**HMAC**는 송**신자와 수신자가 비밀 키를 공유**할 경우 **보안되지 않은 채널**을 통해 보낸 메시지가 **훼손되었는지 여부를 확인**하는데 사용할 수 있다. **송신자는 원래 데이터의 해시 값을 계산하여 원래 데이터와 해시 값을 모두 단일 메시지로 보내고, 수신자는 받은 메시지에 대해 해시 값을다시 게산하고 계산된 HMAC가 전송된 HMAC와 일치하는지 확인합니다.**

---

### 내용(Payload)

**JWT의 내용**에는 **토큰에 담는 정보**를 포함합니다. 이곳에 포함된 속성들은 클레임(Claim)이라 하며, 크게 세 가지로 분류됩니다. 

- 등록된 클레임(Registered Claims)
- 공개 클레임(Public Claims)
- 비공개 클레임(Private Claims)

 

---

**등록된 클레임**은 서비스에서 필요한 정보들이 아닌, 토큰에 대한 정보들을 담기 위하여 이름이 이미 정해진 클레임 들 입니다. 등록된 클레임의 사용은 모두 선택적이며, 이에 포함된 이름들은 다음과 같습니다.

- **iss**: JWT의 발급자(Issuer) 주체를 나타냅니다. iss의 값은 문자열이나 URI를 포함하는 대소문자를 구분하는 문자열입니다.
- **sub**: JWT의 제목(Subject)입니다.
- **aud**: JWT의 수신인(Audience)입니다. JWT를 처리하려는 각 주체는 해당 값으로 자신을 식별해야 합니다.   요청을 처리하는 주체가 ‘aud’ 값으로 자신을 식별하지 않으면 JWT는 거부됩니다.
- **exp**: JWT의 만료시간(Expiration)입니다.  시간은 NumericDate 형식으로 지정해야 합니다.
- **nbf**: ‘Not Before’ 를 의미합니다.
- **iat**: JWT가 발급된 시간(Issued at) 입니다.
- **jti**: JWT의 식별자(JWT ID)입니다. 주로 중복 처리를 방지하기 위해 사용됩니다.

---

**공개 클레임은 사용자 정의 클레임**으로**, 공개용 정보를 위해 사용**합니다**. 공개 클레임들은** **충돌이 방지된 (collision-resistant) 이름**을 가지고 있어야 합니다.  충돌을 방지하기 위해서는, 클레임 이름을 **URI** 형식으로 짓습니다.

![Untitled](JWT%20608828a493cf4b1e92e5449e85c9935c/Untitled%204.png)

---

**비공개 클레임**은 등록된 클레임도 아니고, 공개된 클레임도 아닙니다. 양 측간에(보통 클라이언트 ↔ 서버) **협의하에 사용되는 클레임 이름들**입니다. 공개 클레임과는 달리 **이름이 중복되어** 충돌이 될 수 있기 때문에 사용할 때에 유의해야 합니다.   
**** 

![Untitled](JWT%20608828a493cf4b1e92e5449e85c9935c/Untitled%205.png)

---

**예제 Payload**

![Untitled](JWT%20608828a493cf4b1e92e5449e85c9935c/Untitled%206.png)

위 예제 payload는 2개의 등록된 클레임과 , 1개의 공개 클레임, 2개의 비공개 클레임으로 이루어져 있습니다.

---

### 서명 (Signature)

**JSON Web Token**의 마지막 부분은 바로 서명(signature)입니다. 이 서명은 **헤더의 인코딩값과, 정보의 인코딩값을 합친 후 주어진 비밀키로 해쉬를 하여 생성**합니다. 

서명 부분을 만드는 수도코드의 구조는 다음과 같습니다.

![Untitled](JWT%20608828a493cf4b1e92e5449e85c9935c/Untitled%207.png)

이렇게 만든 해쉬를, base64형태로 나타내면 됩니다. (문자열을 인코딩 하는게 아닌 hex→base64 인코딩을 해야합니다)

### JWT 디버거 사용하기

위에서 다루었던 값들을 [https://jwt.io/](https://jwt.io/) 사이트에서 디버깅 해볼 수 있습니다. 왼쪽이 인코딩 된 토큰 문자열입니다.

![Untitled](JWT%20608828a493cf4b1e92e5449e85c9935c/Untitled%208.png)

하단에  파란색 글씨로 **Signature Verified 체크** 표시가 뜨면 JWT 토큰이 검증되었다는 뜻 입니다.

---

# Spring에서 JWT 생성

### 1. build.gradle 설정에 io.jsonwebtoken:jjwt 플러그인을 추가

 

![Untitled](JWT%20608828a493cf4b1e92e5449e85c9935c/Untitled%209.png)

### 2. secretKey 등록

![Untitled](JWT%20608828a493cf4b1e92e5449e85c9935c/Untitled%2010.png)

![Untitled](JWT%20608828a493cf4b1e92e5449e85c9935c/Untitled%2011.png)

- 서명에 사용할 secretKey 필드에 기본값을 설정 해 두어서 구성 속성을 통해 secretKey 값이 제공되지 않은 경우에 사용합니다.

### 3. secretKey 초기화

![Untitled](JWT%20608828a493cf4b1e92e5449e85c9935c/Untitled%2012.png)

- secretKey를 Base64 형식으로 변환, Base64로 인코딩된 문자열이 특수 문자, 공백 등을 포함하지 않아서 URL이나 다른 환경에서 안전하게 전송 및  저장될 수 있기 때문입니다.

 

### 4. Jwt 토큰 생성

![Untitled](JWT%20608828a493cf4b1e92e5449e85c9935c/Untitled%2013.png)

1. **Jwts.claims().setSubject(userUid) 를 통해 클레임의 주체를 사용자 UID로 설정합니다.**
2. **claims.put(”roles” roles); 에서 클레임에 사용자의 역할 정보를 추가합니다.** 
3. **Jwt를 생성하기 위해 builder를 시작합니다.**
- 앞서 설정한 클레임을 설정(비공개 클레임)
- 토큰 발급 시간을 설정 (등록된 클레임)
- 토큰의 만료 시간을 설정 (등록된 클레임)// 해당 변수는 1000L *60 * 60(1시간)(등록된 클레임)
- HS256알고리즘과 secretKey로 서명을 추가
- 최종적으로 토큰을 생성하고 문자열로 반환

**헤더 설정은?** 

Spring에서는 일반적으로 Jwts.builder() 메서드를 사용할 때, 헤더 설정을 자동으로 처리해줍니다. 내부적으로는 ‘DefaultJwtBuilder’ 클래스가 사용되며, 이 클래스에서 기본 헤더 값들이 설정됩니다. 

기본값으로 “alg” 부분은 “HS256” 값이 설정되고, “typ” 부분엔 “JWT” 가 설정됩니다.

이렇게 하여 스프링에서 JWT 토큰을 생성할 수 있습니다.

---

# JWT의 문제점

### 1. Payload의 디코딩이 용이하다

Payload는 base64로 인코딩 되어 토큰이 탈취되어 디코딩 되면 토큰 생성시 저장한 데이터를 확인할 수 있다. Payload에 중요한 정보는 담을 수 없습니다.

### 2. 토큰 길이가 길어지면 네트워크에 부하를 줄 수 있다.

토큰에 저장되는 정보 양이 많아질수록 토큰 길이가 길어진다. request를 전송할 때, 길이가 긴 토큰을 함께 전송하면  네트워크 부하를 줄 수 있습니다.

### 3. 서버는 토큰에 대한 제어권이 없다.

JWT는 서버의 부하를 줄이기 위해 탄생한 방법이므로 태생적으로 Stateless(무상태) 입니다. 따라서, 한번 발급된 토큰이 발급되면 서버는 해당 토큰에 대한 제어권을 상실하게 됩니다. 이로서 로그아웃에 문제가 발생할 수 있습니다.