# 유효성 검사

상태: In progress

# 1. 유효성 검사

## 1.1 유효성 검사란?

서비스의 비즈니스 로직이 올바르게 동작하기 위해 사용되는 데이터에 대한 사전 검증하는 작업이 필요합니다. 

유효성 검사 혹은 데이터 검증이라 부르는데 , Validation이라 부릅니다.

데이터의 검증은 여러 계층에서 발생하는 흔한 작업

Validation은 들어오는 데이터에 대해 의도한 형식의 값이 제대로 들어오는지 체크하는 과정을 뜻한다.

## 1.2 유효성 검사가 필요한 이유

예를 들어 회원가입의 상황에서 생년월일, 이메일 등등 사용자가 입력을 할 때, 생년월일을 2023-110-2000 , 이메일을 홍길순 이라 입력을 하면 무의미한 데이터가 되어 문제가 생깁니다. 

# 2. Spring에서의 유효성 검사

## 2.1 유효성 검사를 실시하는 위치

유효성 검사가 가능한 위치는 Client와 Server가 있습니다. 

---

1. **Client**

빠르게 검증이 가능하다는 장점이 있습니다. 그러나 클라이언트는 사용자가 제어하기 때문에 악의적인 사용자가 검사를 우회 하거나 조작할 수 있습니다 또한 db를 통한 중복 검사 등이 불가능합니다.

1. **Server**

클라이언트에서 하는 검사에 비해 보안이 강화됩니다. 그리고 서버 측에서 유효성 검사를 하게 되면 애플리케이션 전체에서 일관된 규칙을 적용할 수 있습니다.  또한 db를 통한 검증이 가능해집니다. 그러나 서버 부하가 증가하고, 응답 반응 속도가 느려질 수 있습니다. 또한 db를 통한 검증이 가능해집니다.

결론적으로 말하자면 둘 다 검사를 하는 게 베스트, 둘 중 하나에서 해야 한다면 Server 라고 할 수 있습니다.  

---

그렇다면 Server에서는 어디에 유효성 검사를 하는 것이 좋을까?

**정답은 모든 계층에서 하는 것이 좋다!**

1. **Controller 계층** 에서는 기본적인 사용자 인터페이스 수준의 유효성 검사를  수행합니다. 잘못된 입력을 미리 방지 할 수 있습니다.  
2. **Service 계층** 에서는 비즈니스 로직 수행 전에 더 정교한 유효성 검사를 수행합니다. 애플리케이션의 비즈니스 규칙 및 제약을 준수하는지 확인합니다.
3. **데이터베이스 계층** 에서는  데이터베이스에 데이터를 저장하기 전에 데이터베이스 수준에서 유효성 검사를 수행합니다. 이는 데이터베이스의 일관성을 보장하고, 무결성 또한 유지합니다.

## 2.2 @Valid와 @Validated

---

**@Valid 란?**

- 자바 표준 스펙(JSR-303) 으로 지정되어있는 Bean Validation 기능
- 빈 검증기(Bean Validator) 를 이용해 객체의 제약 조건을 검증하도록 지시하는 어노테이션.
- @Valid는 기본적으로 컨트롤러에서만 동작하며, 기본적으로 다른 계층에서는 검증이 되지 않는다.
- 유효성 검증에 실패할 경우, MethodArgumentNotVaildException이 발생

---

**@Valid 사용 방법**

![Untitled](%E1%84%8B%E1%85%B2%E1%84%92%E1%85%AD%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A1%20ca6510890ca3485da79e634557e06999/Untitled.png)

![Untitled](%E1%84%8B%E1%85%B2%E1%84%92%E1%85%AD%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A1%20ca6510890ca3485da79e634557e06999/Untitled%201.png)

---

**@Valid 동작 원리**

![Untitled](%E1%84%8B%E1%85%B2%E1%84%92%E1%85%AD%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A1%20ca6510890ca3485da79e634557e06999/Untitled%202.png)

1. 클라이언트에서 컨트롤러 호출
2. Dispatcher Servlet에서 요청에 맞는 컨트롤러 탐색
3. RequestResponseBodyMethodProcessor 에서 @Vaild  로 시작하는 어노테이션이 있을 경우에 유효성 검사 진행. 
4. 검증에 오류가 있는 경우 MethodArgumentNotValidException 예외 발생, Dispatcher Servlet에 기본으로 등록된 예외 리졸버(Exception Resolver)인 DefaultHandlerExceptionResolver에 의해 400 BadRequest 에러 발생.

결론은 **@RequestBody**로 선언된 객체에 **@Valid** 어노테이션이 있으면 유효성 검사를 수행하는 것이며, 컨트롤러 단에서만 동작한다.

---

**@Validated 란?**

입력 파라미터의 유효성 검사를 컨트롤러에서 처리 해도, 불가피하게 다른 곳에서 파라미터를 검증해야 할 수 있다. 

Spring은 이를 위해 **AOP기반**으로 메소드의 요청을 가로채서 유효성 검증을 진행해주는 **@Validated** 를 제공하고 있다.

**@Validated** 는 JSR 표준 기술이 아니며 **Spring 프레임워크** 에서 제공하는 어노테이션 및 기능.

클래스에 **@Validated**를 붙여주고, 유효성을 검증할 메소드의 파라미터에 **@Valid(혹은 다른 Valid어노테이션)** 을 붙여주면 해당 매개변수에 유효성 검증이 진행.

![Untitled](%E1%84%8B%E1%85%B2%E1%84%92%E1%85%AD%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A1%20ca6510890ca3485da79e634557e06999/Untitled%203.png)

---

**@Validated의 동작 원리**

**@Validated** 를 붙이면, AOP에 등록되고,

**MethodValidationInterceptor** 클래스에서 가로채서 실행

![Untitled](%E1%84%8B%E1%85%B2%E1%84%92%E1%85%AD%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A1%20ca6510890ca3485da79e634557e06999/Untitled%204.png)

**@Validated**는 AOP 기반으로 메소드 요청을 인터셉터 하여 처리된다. 

**@Validated 를 클래스 레벨에 선언하면 해당 클래스에 유효성 검사를 위한 AOP의 어드바이스 또는 인터셉터(MethodValidationInterceptor)가 등록된다.** 

그리고 해당 메소드들이 호출될 때 **AOP의 포인트 컷**으로써 요청을 가로채서 유효성 검증을 진행한다. 이러한 이유로 **@Validated를 사용하면 컨트롤러 서비스 레포지토리 등 계층에 무관하게 스프링 빈이라면 유효성 검증**을 진행할 수 있다.

@Validated에 의한 예외는 **ConstraintViolationException**입니다.

---

**@Validated의 또 다른 기능(유효성 검증 그룹의 지정)**

동일한 클래스에 대해 제약조건이 요청에 따라 다른 경우.

제약 조건이 적용될 검증 그룹을 지정할 수 있는 기능.

분리를 위한 내용이 없는 인터페이스 선언.

![Untitled](%E1%84%8B%E1%85%B2%E1%84%92%E1%85%AD%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A1%20ca6510890ca3485da79e634557e06999/Untitled%205.png)

해당 제약 조건이 적용될 그룹을 groups로 지정

![Untitled](%E1%84%8B%E1%85%B2%E1%84%92%E1%85%AD%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A1%20ca6510890ca3485da79e634557e06999/Untitled%206.png)

컨트롤러 에도 다음과 같은 제약조건 검증을 적용할 클래스 지정

 

![Untitled](%E1%84%8B%E1%85%B2%E1%84%92%E1%85%AD%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A1%20ca6510890ca3485da79e634557e06999/Untitled%207.png)

이렇게 UserValidationGroup 클래스를 @Validated 의 파라미터로 넣어주었다면 UserValidationGroup 에 해당하는 제약 조건만 검증이 된다. 

---

## 2.3 유효성 검사를 위한 어노테이션들

![Untitled](%E1%84%8B%E1%85%B2%E1%84%92%E1%85%AD%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A1%20ca6510890ca3485da79e634557e06999/Untitled%208.png)

**@Pattern 어노테이션은 문자열을 위한 것. 문자열이 아닌 다른 형식에는 사용 x**

**또한, int형에 대한 널체크로 @NotBlank가 아니라 @NotNull을 사용해야한다.**